<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wallpaper Pattern Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 30px;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .control-panel {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            height: fit-content;
            border: 1px solid #e9ecef;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group h3 {
            margin-bottom: 15px;
            color: #495057;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group h3::before {
            content: '';
            width: 4px;
            height: 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 2px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #495057;
        }

        input, select {
            width: 100%;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .color-input {
            height: 45px;
            cursor: pointer;
        }

        .button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 10px;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px rgba(102, 126, 234, 0.3);
        }

        .button:active {
            transform: translateY(0);
        }

        .button.secondary {
            background: #6c757d;
        }

        .button.secondary:hover {
            background: #5a6268;
            box-shadow: 0 8px 15px rgba(108, 117, 125, 0.3);
        }

        .preview-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .preview-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #e9ecef;
        }

        .preview-container {
            position: relative;
            background: #fff;
            border: 2px solid #e9ecef;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        #patternCanvas {
            display: block;
            max-width: 100%;
            height: auto;
        }

        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .pattern-item {
            padding: 15px;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-size: 12px;
            font-weight: 500;
        }

        .pattern-item:hover {
            border-color: #667eea;
            background: #f8f9ff;
            transform: translateY(-2px);
        }

        .pattern-item.active {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid #e9ecef;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
            display: block;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #6c757d;
            margin-top: 5px;
        }

        .advanced-controls {
            display: none;
            margin-top: 15px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 8px;
        }

        .advanced-controls.show {
            display: block;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-group input[type="range"] {
            flex: 1;
        }

        .slider-value {
            min-width: 40px;
            font-weight: bold;
            color: #667eea;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .control-panel {
                order: 2;
            }
        }

        .loading {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,255,255,0.9);
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ¨ Wallpaper Pattern Generator</h1>
            <p>Create stunning seamless patterns for wallpapers and UI backgrounds</p>
        </div>

        <div class="main-content">
            <div class="control-panel">
                <div class="control-group">
                    <h3>Pattern Type</h3>
                    <div class="pattern-grid">
                        <div class="pattern-item active" data-pattern="geometric">Geometric</div>
                        <div class="pattern-item" data-pattern="organic">Organic</div>
                        <div class="pattern-item" data-pattern="minimalist">Minimal</div>
                        <div class="pattern-item" data-pattern="abstract">Abstract</div>
                        <div class="pattern-item" data-pattern="mandala">Mandala</div>
                        <div class="pattern-item" data-pattern="hexagon">Hexagon</div>
                    </div>
                </div>

                <div class="control-group">
                    <h3>Colors</h3>
                    <div class="form-group">
                        <label>Primary Color</label>
                        <input type="color" id="primaryColor" class="color-input" value="#667eea">
                    </div>
                    <div class="form-group">
                        <label>Secondary Color</label>
                        <input type="color" id="secondaryColor" class="color-input" value="#764ba2">
                    </div>
                    <div class="form-group">
                        <label>Background Color</label>
                        <input type="color" id="backgroundColor" class="color-input" value="#ffffff">
                    </div>
                </div>

                <div class="control-group">
                    <h3>Dimensions</h3>
                    <div class="form-group">
                        <label>Tile Size</label>
                        <div class="slider-group">
                            <input type="range" id="tileSize" min="100" max="500" value="200">
                            <span class="slider-value" id="tileSizeValue">200px</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Pattern Density</label>
                        <div class="slider-group">
                            <input type="range" id="density" min="1" max="10" value="5">
                            <span class="slider-value" id="densityValue">5</span>
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <h3>Effects</h3>
                    <div class="form-group">
                        <label>Rotation (degrees)</label>
                        <div class="slider-group">
                            <input type="range" id="rotation" min="0" max="360" value="0">
                            <span class="slider-value" id="rotationValue">0Â°</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Scale</label>
                        <div class="slider-group">
                            <input type="range" id="scale" min="0.5" max="2" step="0.1" value="1">
                            <span class="slider-value" id="scaleValue">1.0x</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Opacity</label>
                        <div class="slider-group">
                            <input type="range" id="opacity" min="0.1" max="1" step="0.1" value="1">
                            <span class="slider-value" id="opacityValue">100%</span>
                        </div>
                    </div>
                </div>

                <button class="button" onclick="toggleAdvanced()">Advanced Settings</button>
                <div class="advanced-controls" id="advancedControls">
                    <div class="form-group">
                        <label>Blend Mode</label>
                        <select id="blendMode">
                            <option value="normal">Normal</option>
                            <option value="multiply">Multiply</option>
                            <option value="screen">Screen</option>
                            <option value="overlay">Overlay</option>
                            <option value="soft-light">Soft Light</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Shadow Blur</label>
                        <div class="slider-group">
                            <input type="range" id="shadowBlur" min="0" max="20" value="0">
                            <span class="slider-value" id="shadowBlurValue">0px</span>
                        </div>
                    </div>
                </div>

                <button class="button" onclick="generatePattern()">ðŸŽ¨ Generate Pattern</button>
                <button class="button" onclick="randomizeSettings()">ðŸŽ² Randomize</button>
                <button class="button secondary" onclick="exportPattern()">ðŸ’¾ Export PNG</button>
                <button class="button secondary" onclick="exportSVG()">ðŸ“„ Export SVG</button>
            </div>

            <div class="preview-area">
                <div class="preview-controls">
                    <label>Preview Size:</label>
                    <select id="previewSize" onchange="updatePreviewSize()">
                        <option value="400">Small (400px)</option>
                        <option value="600" selected>Medium (600px)</option>
                        <option value="800">Large (800px)</option>
                        <option value="1000">Extra Large (1000px)</option>
                    </select>
                    <button class="button" onclick="toggleFullscreen()" style="width: auto; padding: 8px 15px;">â›¶ Fullscreen</button>
                </div>

                <div class="preview-container">
                    <canvas id="patternCanvas" width="600" height="600"></canvas>
                    <div class="loading" id="loading">
                        <div class="spinner"></div>
                        <div>Generating pattern...</div>
                    </div>
                </div>

                <div class="stats">
                    <div class="stat-item">
                        <span class="stat-value" id="patternCount">0</span>
                        <div class="stat-label">Patterns Generated</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="currentSize">200px</span>
                        <div class="stat-label">Tile Size</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="renderTime">0ms</span>
                        <div class="stat-label">Render Time</div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="exportCount">0</span>
                        <div class="stat-label">Exports</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let canvas, ctx;
        let currentPattern = 'geometric';
        let patternCount = 0;
        let exportCount = 0;
        let isFullscreen = false;

        // Initialize the application
        function init() {
            canvas = document.getElementById('patternCanvas');
            ctx = canvas.getContext('2d');
            
            setupEventListeners();
            generatePattern();
            updateSliderValues();
        }

        function setupEventListeners() {
            // Pattern type selection
            document.querySelectorAll('.pattern-item').forEach(item => {
                item.addEventListener('click', function() {
                    document.querySelector('.pattern-item.active').classList.remove('active');
                    this.classList.add('active');
                    currentPattern = this.dataset.pattern;
                    generatePattern();
                });
            });

            // Real-time updates for all inputs
            const inputs = ['primaryColor', 'secondaryColor', 'backgroundColor', 'tileSize', 'density', 'rotation', 'scale', 'opacity', 'blendMode', 'shadowBlur'];
            inputs.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', () => {
                        updateSliderValues();
                        generatePattern();
                    });
                }
            });
        }

        function updateSliderValues() {
            const sliders = [
                { id: 'tileSize', suffix: 'px', target: 'tileSizeValue' },
                { id: 'density', suffix: '', target: 'densityValue' },
                { id: 'rotation', suffix: 'Â°', target: 'rotationValue' },
                { id: 'scale', suffix: 'x', target: 'scaleValue' },
                { id: 'opacity', suffix: '%', target: 'opacityValue', multiplier: 100 },
                { id: 'shadowBlur', suffix: 'px', target: 'shadowBlurValue' }
            ];

            sliders.forEach(slider => {
                const element = document.getElementById(slider.id);
                const target = document.getElementById(slider.target);
                if (element && target) {
                    const value = slider.multiplier ? (element.value * slider.multiplier) : element.value;
                    target.textContent = value + slider.suffix;
                }
            });

            // Update current size stat
            document.getElementById('currentSize').textContent = document.getElementById('tileSize').value + 'px';
        }

        function generatePattern() {
            const startTime = performance.now();
            showLoading(true);

            // Small delay to show loading animation
            setTimeout(() => {
                const tileSize = parseInt(document.getElementById('tileSize').value);
                canvas.width = tileSize;
                canvas.height = tileSize;

                // Clear canvas
                ctx.clearRect(0, 0, tileSize, tileSize);
                
                // Set background
                ctx.fillStyle = document.getElementById('backgroundColor').value;
                ctx.fillRect(0, 0, tileSize, tileSize);

                // Apply global settings
                ctx.globalAlpha = parseFloat(document.getElementById('opacity').value);
                ctx.globalCompositeOperation = document.getElementById('blendMode').value;

                // Generate pattern based on type
                switch(currentPattern) {
                    case 'geometric':
                        drawGeometricPattern();
                        break;
                    case 'organic':
                        drawOrganicPattern();
                        break;
                    case 'minimalist':
                        drawMinimalistPattern();
                        break;
                    case 'abstract':
                        drawAbstractPattern();
                        break;
                    case 'mandala':
                        drawMandalaPattern();
                        break;
                    case 'hexagon':
                        drawHexagonPattern();
                        break;
                }

                // Update stats
                patternCount++;
                const renderTime = Math.round(performance.now() - startTime);
                document.getElementById('patternCount').textContent = patternCount;
                document.getElementById('renderTime').textContent = renderTime + 'ms';

                showLoading(false);
                updatePreviewSize();
            }, 100);
        }

        function drawGeometricPattern() {
            const tileSize = canvas.width;
            const density = parseInt(document.getElementById('density').value);
            const primary = document.getElementById('primaryColor').value;
            const secondary = document.getElementById('secondaryColor').value;
            const rotation = parseFloat(document.getElementById('rotation').value) * Math.PI / 180;
            const scale = parseFloat(document.getElementById('scale').value);
            const shadowBlur = parseInt(document.getElementById('shadowBlur').value);

            ctx.save();
            ctx.translate(tileSize/2, tileSize/2);
            ctx.rotate(rotation);
            ctx.scale(scale, scale);

            if (shadowBlur > 0) {
                ctx.shadowBlur = shadowBlur;
                ctx.shadowColor = 'rgba(0,0,0,0.3)';
            }

            const gridSize = density * 2;
            const cellSize = tileSize / gridSize;

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const x = (i - gridSize/2) * cellSize;
                    const y = (j - gridSize/2) * cellSize;
                    
                    ctx.fillStyle = (i + j) % 2 === 0 ? primary : secondary;
                    
                    if (density > 7) {
                        // Circles for high density
                        ctx.beginPath();
                        ctx.arc(x + cellSize/2, y + cellSize/2, cellSize/3, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Rectangles for lower density
                        ctx.fillRect(x, y, cellSize * 0.8, cellSize * 0.8);
                    }
                }
            }
            ctx.restore();
        }

        function drawOrganicPattern() {
            const tileSize = canvas.width;
            const density = parseInt(document.getElementById('density').value);
            const primary = document.getElementById('primaryColor').value;
            const secondary = document.getElementById('secondaryColor').value;
            const scale = parseFloat(document.getElementById('scale').value);

            ctx.save();
            ctx.scale(scale, scale);

            const numShapes = density * 3;
            
            for (let i = 0; i < numShapes; i++) {
                const x = Math.random() * tileSize;
                const y = Math.random() * tileSize;
                const radius = Math.random() * 30 + 10;
                
                ctx.fillStyle = Math.random() > 0.5 ? primary : secondary;
                
                // Organic blob shape
                ctx.beginPath();
                const points = 6 + Math.floor(Math.random() * 6);
                for (let j = 0; j < points; j++) {
                    const angle = (j / points) * Math.PI * 2;
                    const r = radius + Math.sin(angle * 3) * 5;
                    const px = x + Math.cos(angle) * r;
                    const py = y + Math.sin(angle) * r;
                    if (j === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
        }

        function drawMinimalistPattern() {
            const tileSize = canvas.width;
            const primary = document.getElementById('primaryColor').value;
            const secondary = document.getElementById('secondaryColor').value;
            const density = parseInt(document.getElementById('density').value);
            const rotation = parseFloat(document.getElementById('rotation').value) * Math.PI / 180;

            ctx.save();
            ctx.translate(tileSize/2, tileSize/2);
            ctx.rotate(rotation);

            // Simple lines or dots
            ctx.strokeStyle = primary;
            ctx.fillStyle = secondary;
            ctx.lineWidth = 2;

            const spacing = tileSize / (density + 1);
            
            for (let i = 1; i <= density; i++) {
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(-tileSize/2 + i * spacing, -tileSize/2);
                ctx.lineTo(-tileSize/2 + i * spacing, tileSize/2);
                ctx.stroke();
                
                // Horizontal lines
                ctx.beginPath();
                ctx.moveTo(-tileSize/2, -tileSize/2 + i * spacing);
                ctx.lineTo(tileSize/2, -tileSize/2 + i * spacing);
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawAbstractPattern() {
            const tileSize = canvas.width;
            const density = parseInt(document.getElementById('density').value);
            const primary = document.getElementById('primaryColor').value;
            const secondary = document.getElementById('secondaryColor').value;
            const scale = parseFloat(document.getElementById('scale').value);

            ctx.save();
            ctx.scale(scale, scale);

            // Abstract flowing shapes
            const numWaves = density;
            for (let i = 0; i < numWaves; i++) {
                const gradient = ctx.createLinearGradient(0, 0, tileSize, tileSize);
                gradient.addColorStop(0, primary);
                gradient.addColorStop(1, secondary);
                ctx.fillStyle = gradient;

                ctx.beginPath();
                ctx.moveTo(0, tileSize * i / numWaves);
                
                for (let x = 0; x <= tileSize; x += 10) {
                    const y = tileSize * i / numWaves + 
                             Math.sin(x * 0.02 + i) * 20 + 
                             Math.sin(x * 0.01 + i * 2) * 10;
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(tileSize, tileSize);
                ctx.lineTo(0, tileSize);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
        }

        function drawMandalaPattern() {
            const tileSize = canvas.width;
            const primary = document.getElementById('primaryColor').value;
            const secondary = document.getElementById('secondaryColor').value;
            const density = parseInt(document.getElementById('density').value);
            const scale = parseFloat(document.getElementById('scale').value);

            ctx.save();
            ctx.translate(tileSize/2, tileSize/2);
            ctx.scale(scale, scale);

            const layers = density;
            const maxRadius = tileSize/3;

            for (let layer = 0; layer < layers; layer++) {
                const radius = (maxRadius / layers) * (layer + 1);
                const petals = 6 + layer * 2;
                
                ctx.strokeStyle = layer % 2 === 0 ? primary : secondary;
                ctx.lineWidth = 2;

                for (let i = 0; i < petals; i++) {
                    const angle = (i / petals) * Math.PI * 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    ctx.lineTo(x, y);
                    
                    // Petal decoration
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            ctx.restore();
        }

        function drawHexagonPattern() {
            const tileSize = canvas.width;
            const primary = document.getElementById('primaryColor').value;
            const secondary = document.getElementById('secondaryColor').value;
            const density = parseInt(document.getElementById('density').value);
            const scale = parseFloat(document.getElementById('scale').value);

            ctx.save();
            ctx.scale(scale, scale);

            const hexSize = tileSize / (density + 2);
            const hexHeight = hexSize * Math.sqrt(3);
            
            for (let row = -1; row < density + 2; row++) {
                for (let col = -1; col < density + 2; col++) {
                    const x = col * hexSize * 1.5;
                    const y = row * hexHeight + (col % 2) * hexHeight / 2;
                    
                    ctx.fillStyle = (row + col) % 2 === 0 ? primary : secondary;
                    
                    // Draw hexagon
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const px = x + Math.cos(angle) * hexSize / 2;
                        const py = y + Math.sin(angle) * hexSize / 2;
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
            ctx.restore();
        }

        function randomizeSettings() {
            // Randomize colors
            document.getElementById('primaryColor').value = getRandomColor();
            document.getElementById('secondaryColor').value = getRandomColor();
            document.getElementById('backgroundColor').value = getRandomColor();
            
            // Randomize sliders
            document.getElementById('tileSize').value = Math.floor(Math.random() * 400) + 100;
            document.getElementById('density').value = Math.floor(Math.random() * 10) + 1;
            document.getElementById('rotation').value = Math.floor(Math.random() * 360);
            document.getElementById('scale').value = (Math.random() * 1.5 + 0.5).toFixed(1);
            document.getElementById('opacity').value = (Math.random() * 0.5 + 0.5).toFixed(1);
            
            // Randomize pattern type
            const patterns = ['geometric', 'organic', 'minimalist', 'abstract', 'mandala', 'hexagon'];
            const randomPattern = patterns[Math.floor(Math.random() * patterns.length)];
            document.querySelector('.pattern-item.active').classList.remove('active');
            document.querySelector(`[data-pattern="${randomPattern}"]`).classList.add('active');
            currentPattern = randomPattern;
            
            updateSliderValues();
            generatePattern();
        }

        function getRandomColor() {
            return '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
        }

        function exportPattern() {
            const link = document.createElement('a');
            link.download = `wallpaper-pattern-${currentPattern}-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
            
            exportCount++;
            document.getElementById('exportCount').textContent = exportCount;
        }

        function exportSVG() {
            // Create SVG representation
            const tileSize = parseInt(document.getElementById('tileSize').value);
            const primary = document.getElementById('primaryColor').value;
            const secondary = document.getElementById('secondaryColor').value;
            const background = document.getElementById('backgroundColor').value;
            
            let svgContent = `<svg width="${tileSize}" height="${tileSize}" xmlns="http://www.w3.org/2000/svg">
                <rect width="100%" height="100%" fill="${background}"/>`;
            
            // Generate SVG based on current pattern
            switch(currentPattern) {
                case 'geometric':
                    svgContent += generateGeometricSVG(tileSize, primary, secondary);
                    break;
                case 'minimalist':
                    svgContent += generateMinimalistSVG(tileSize, primary, secondary);
                    break;
                default:
                    svgContent += `<text x="50%" y="50%" text-anchor="middle" fill="${primary}">SVG Export</text>`;
            }
            
            svgContent += '</svg>';
            
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const link = document.createElement('a');
            link.download = `wallpaper-pattern-${currentPattern}-${Date.now()}.svg`;
            link.href = URL.createObjectURL(blob);
            link.click();
            
            exportCount++;
            document.getElementById('exportCount').textContent = exportCount;
        }

        function generateGeometricSVG(tileSize, primary, secondary) {
            const density = parseInt(document.getElementById('density').value);
            const gridSize = density * 2;
            const cellSize = tileSize / gridSize;
            let svg = '';
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const x = i * cellSize;
                    const y = j * cellSize;
                    const color = (i + j) % 2 === 0 ? primary : secondary;
                    
                    if (density > 7) {
                        svg += `<circle cx="${x + cellSize/2}" cy="${y + cellSize/2}" r="${cellSize/3}" fill="${color}"/>`;
                    } else {
                        svg += `<rect x="${x}" y="${y}" width="${cellSize * 0.8}" height="${cellSize * 0.8}" fill="${color}"/>`;
                    }
                }
            }
            return svg;
        }

        function generateMinimalistSVG(tileSize, primary, secondary) {
            const density = parseInt(document.getElementById('density').value);
            const spacing = tileSize / (density + 1);
            let svg = '';
            
            for (let i = 1; i <= density; i++) {
                svg += `<line x1="${i * spacing}" y1="0" x2="${i * spacing}" y2="${tileSize}" stroke="${primary}" stroke-width="2"/>`;
                svg += `<line x1="0" y1="${i * spacing}" x2="${tileSize}" y2="${i * spacing}" stroke="${primary}" stroke-width="2"/>`;
            }
            return svg;
        }

        function updatePreviewSize() {
            const size = parseInt(document.getElementById('previewSize').value);
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';
        }

        function toggleFullscreen() {
            const container = document.querySelector('.preview-container');
            
            if (!isFullscreen) {
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                } else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }
                isFullscreen = true;
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                isFullscreen = false;
            }
        }

        function toggleAdvanced() {
            const controls = document.getElementById('advancedControls');
            controls.classList.toggle('show');
        }

        function showLoading(show) {
            const loading = document.getElementById('loading');
            if (show) {
                loading.classList.add('show');
            } else {
                loading.classList.remove('show');
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'g':
                        e.preventDefault();
                        generatePattern();
                        break;
                    case 'r':
                        e.preventDefault();
                        randomizeSettings();
                        break;
                    case 's':
                        e.preventDefault();
                        exportPattern();
                        break;
                    case 'e':
                        e.preventDefault();
                        exportSVG();
                        break;
                }
            }
            
            // Number keys for pattern selection
            if (e.key >= '1' && e.key <= '6') {
                const patterns = ['geometric', 'organic', 'minimalist', 'abstract', 'mandala', 'hexagon'];
                const index = parseInt(e.key) - 1;
                if (patterns[index]) {
                    document.querySelector('.pattern-item.active').classList.remove('active');
                    document.querySelector(`[data-pattern="${patterns[index]}"]`).classList.add('active');
                    currentPattern = patterns[index];
                    generatePattern();
                }
            }
        });

        // Fullscreen change events
        document.addEventListener('fullscreenchange', () => {
            isFullscreen = !!document.fullscreenElement;
        });

        document.addEventListener('webkitfullscreenchange', () => {
            isFullscreen = !!document.webkitFullscreenElement;
        });

        // Auto-save functionality
        let autoSaveInterval;
        function startAutoSave() {
            if (autoSaveInterval) clearInterval(autoSaveInterval);
            autoSaveInterval = setInterval(() => {
                const settings = {
                    pattern: currentPattern,
                    primaryColor: document.getElementById('primaryColor').value,
                    secondaryColor: document.getElementById('secondaryColor').value,
                    backgroundColor: document.getElementById('backgroundColor').value,
                    tileSize: document.getElementById('tileSize').value,
                    density: document.getElementById('density').value,
                    rotation: document.getElementById('rotation').value,
                    scale: document.getElementById('scale').value,
                    opacity: document.getElementById('opacity').value,
                    blendMode: document.getElementById('blendMode').value,
                    shadowBlur: document.getElementById('shadowBlur').value
                };
                
                // Store in memory (not localStorage due to artifact restrictions)
                window.lastSettings = settings;
            }, 5000); // Auto-save every 5 seconds
        }

        // Performance monitoring
        function trackPerformance() {
            const observer = new PerformanceObserver((list) => {
                const entries = list.getEntries();
                entries.forEach((entry) => {
                    if (entry.name === 'generatePattern') {
                        console.log(`Pattern generation took: ${entry.duration}ms`);
                    }
                });
            });
            observer.observe({ entryTypes: ['measure'] });
        }

        // Color palette suggestions
        const colorPalettes = [
            { name: 'Ocean', primary: '#667eea', secondary: '#764ba2', background: '#ffffff' },
            { name: 'Sunset', primary: '#ff7e5f', secondary: '#feb47b', background: '#ffffff' },
            { name: 'Forest', primary: '#11998e', secondary: '#38ef7d', background: '#f8f9fa' },
            { name: 'Purple', primary: '#8360c3', secondary: '#2ebf91', background: '#ffffff' },
            { name: 'Coral', primary: '#ff9a9e', secondary: '#fecfef', background: '#ffffff' },
            { name: 'Dark', primary: '#434343', secondary: '#000000', background: '#f0f0f0' }
        ];

        function applyColorPalette(index) {
            const palette = colorPalettes[index];
            if (palette) {
                document.getElementById('primaryColor').value = palette.primary;
                document.getElementById('secondaryColor').value = palette.secondary;
                document.getElementById('backgroundColor').value = palette.background;
                generatePattern();
            }
        }

        // Add color palette UI
        function addColorPaletteUI() {
            const colorGroup = document.querySelector('.control-group:nth-child(2)');
            const paletteDiv = document.createElement('div');
            paletteDiv.innerHTML = `
                <div style="margin-top: 15px;">
                    <label style="margin-bottom: 10px; display: block;">Quick Palettes:</label>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px;">
                        ${colorPalettes.map((palette, index) => 
                            `<button onclick="applyColorPalette(${index})" 
                                     style="padding: 8px; font-size: 12px; border: 1px solid #ddd; 
                                            border-radius: 4px; background: linear-gradient(45deg, ${palette.primary}, ${palette.secondary}); 
                                            color: white; cursor: pointer; border: none;">
                                ${palette.name}
                             </button>`
                        ).join('')}
                    </div>
                </div>
            `;
            colorGroup.appendChild(paletteDiv);
        }

        // Pattern presets
        const patternPresets = {
            'geometric': [
                { name: 'Checkerboard', density: 8, rotation: 0, scale: 1 },
                { name: 'Diamond Grid', density: 6, rotation: 45, scale: 0.8 },
                { name: 'Large Blocks', density: 3, rotation: 0, scale: 1.2 }
            ],
            'organic': [
                { name: 'Scattered', density: 4, scale: 0.8 },
                { name: 'Dense Forest', density: 8, scale: 1.2 },
                { name: 'Minimal Organic', density: 2, scale: 1 }
            ]
        };

        // Add preset functionality
        function applyPreset(patternType, presetIndex) {
            const preset = patternPresets[patternType]?.[presetIndex];
            if (preset) {
                if (preset.density) document.getElementById('density').value = preset.density;
                if (preset.rotation !== undefined) document.getElementById('rotation').value = preset.rotation;
                if (preset.scale) document.getElementById('scale').value = preset.scale;
                updateSliderValues();
                generatePattern();
            }
        }

        // Batch export functionality
        function batchExport() {
            const originalPattern = currentPattern;
            const patterns = ['geometric', 'organic', 'minimalist', 'abstract', 'mandala', 'hexagon'];
            let currentIndex = 0;

            function exportNext() {
                if (currentIndex < patterns.length) {
                    currentPattern = patterns[currentIndex];
                    generatePattern();
                    
                    setTimeout(() => {
                        exportPattern();
                        currentIndex++;
                        setTimeout(exportNext, 500); // Delay between exports
                    }, 1000); // Wait for pattern generation
                } else {
                    currentPattern = originalPattern;
                    generatePattern();
                }
            }

            exportNext();
        }

        // Initialize everything when page loads
        window.addEventListener('load', function() {
            init();
            addColorPaletteUI();
            startAutoSave();
            trackPerformance();
            
            // Add batch export button
            const exportArea = document.querySelector('.control-panel');
            const batchButton = document.createElement('button');
            batchButton.className = 'button secondary';
            batchButton.innerHTML = 'ðŸ“¦ Batch Export All';
            batchButton.onclick = batchExport;
            exportArea.appendChild(batchButton);
            
            // Add keyboard shortcuts info
            const infoDiv = document.createElement('div');
            infoDiv.innerHTML = `
                <div style="margin-top: 20px; padding: 15px; background: #e9ecef; border-radius: 8px; font-size: 12px;">
                    <strong>Keyboard Shortcuts:</strong><br>
                    Ctrl+G: Generate â€¢ Ctrl+R: Randomize<br>
                    Ctrl+S: Export PNG â€¢ Ctrl+E: Export SVG<br>
                    1-6: Select Pattern Type
                </div>
            `;
            exportArea.appendChild(infoDiv);
        });

        // Add touch gesture support for mobile
        let touchStartX, touchStartY;
        canvas.addEventListener('touchstart', function(e) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        });

        canvas.addEventListener('touchend', function(e) {
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;

            // Swipe gestures
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 50) {
                    // Swipe right - next pattern
                    const patterns = ['geometric', 'organic', 'minimalist', 'abstract', 'mandala', 'hexagon'];
                    const currentIndex = patterns.indexOf(currentPattern);
                    const nextIndex = (currentIndex + 1) % patterns.length;
                    document.querySelector('.pattern-item.active').classList.remove('active');
                    document.querySelector(`[data-pattern="${patterns[nextIndex]}"]`).classList.add('active');
                    currentPattern = patterns[nextIndex];
                    generatePattern();
                } else if (deltaX < -50) {
                    // Swipe left - previous pattern
                    const patterns = ['geometric', 'organic', 'minimalist', 'abstract', 'mandala', 'hexagon'];
                    const currentIndex = patterns.indexOf(currentPattern);
                    const prevIndex = currentIndex === 0 ? patterns.length - 1 : currentIndex - 1;
                    document.querySelector('.pattern-item.active').classList.remove('active');
                    document.querySelector(`[data-pattern="${patterns[prevIndex]}"]`).classList.add('active');
                    currentPattern = patterns[prevIndex];
                    generatePattern();
                }
            } else if (deltaY < -50) {
                // Swipe up - randomize
                randomizeSettings();
            }
        });
    </script>
</body>
</html>